<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Conway's Game of Life - Charlie Sands</title>
  <style>
    html, body { background: #fff; color: #111; margin: 0; padding: 0; }
    body { font: 16px/1.6 ui-serif, Georgia, Cambria, "Times New Roman", Times, serif; }
    .wrap { max-width: 800px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 24px; margin: 0 0 16px; }
    .controls { margin: 16px 0; display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    button {
      padding: 8px 16px;
      background: #2b59ff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover { background: #1e42cc; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    button.active { background: #ff5722; }
    #canvas {
      border: 1px solid #ddd;
      cursor: crosshair;
      display: block;
      margin: 16px 0;
    }
    .info { font-size: 14px; color: #555; margin: 8px 0; }
    .back { margin-top: 24px; font-size: 14px; }
    a { color: #2b59ff; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <main class="wrap">
    <h1>Conway's Game of Life</h1>
    <p class="info">Click cells to toggle them. Press Start to begin simulation.</p>

    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <button id="clearBtn">Clear</button>
      <button id="randomBtn">Random</button>
      <span class="info">Generation: <span id="generation">0</span></span>
    </div>
    <div class="controls">
      <button id="conwayBtn" class="active">Conway</button>
      <button id="goBtn">Go!</button>
      <button id="tetrisBtn">Tetris</button>
      <button id="antBtn">Langton's Ant</button>
      <button id="sandpileBtn">Sandpile</button>
      <button id="wireworldBtn">Wireworld</button>
    </div>

    <canvas id="canvas" width="600" height="400"></canvas>

    <p class="back"><a href="index.html">‚Üê Back to home</a></p>
  </main>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const clearBtn = document.getElementById('clearBtn');
    const randomBtn = document.getElementById('randomBtn');
    const conwayBtn = document.getElementById('conwayBtn');
    const goBtn = document.getElementById('goBtn');
    const tetrisBtn = document.getElementById('tetrisBtn');
    const antBtn = document.getElementById('antBtn');
    const sandpileBtn = document.getElementById('sandpileBtn');
    const wireworldBtn = document.getElementById('wireworldBtn');
    const generationDisplay = document.getElementById('generation');

    const gameButtons = [conwayBtn, goBtn, tetrisBtn, antBtn, sandpileBtn, wireworldBtn];

    const cellSize = 10;
    const cols = canvas.width / cellSize;
    const rows = canvas.height / cellSize;

    let grid = createGrid();
    let colors = createGrid();
    let sandpileValues = createGrid(); // For sandpile mode
    let running = false;
    let generation = 0;
    let intervalId = null;
    let gameMode = 'conway'; // 'conway', 'go', 'tetris', 'ant', 'sandpile', 'wireworld'

    // Ant state
    let antRow = 0;
    let antCol = 0;
    let antDir = 0; // 0=up, 1=right, 2=down, 3=left

    // Two colors for Go stones (black and white)
    const goColors = ['#111', '#fff'];

    // Tetris colors
    const tetrisColors = [
      '#ff5722', '#2196f3', '#4caf50', '#ff9800',
      '#9c27b0', '#00bcd4', '#ffeb3b', '#e91e63'
    ];

    // Wireworld colors
    const wireworldColors = {
      empty: 0,
      conductor: 1,
      electronHead: 2,
      electronTail: 3
    };

    function createGrid() {
      return Array(rows).fill(null).map(() => Array(cols).fill(0));
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          ctx.strokeStyle = '#e0e0e0';
          ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);

          if (gameMode === 'sandpile') {
            const val = sandpileValues[i][j];
            if (val > 0) {
              const intensity = Math.min(val * 50, 255);
              ctx.fillStyle = `rgb(${intensity}, ${Math.max(0, 200 - val * 30)}, ${Math.max(0, 100 - val * 20)})`;
              ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
              if (val < 10) {
                ctx.fillStyle = '#000';
                ctx.font = '8px monospace';
                ctx.fillText(val, j * cellSize + 2, i * cellSize + 8);
              }
            }
          } else if (gameMode === 'wireworld') {
            const val = grid[i][j];
            if (val === wireworldColors.conductor) {
              ctx.fillStyle = '#ffeb3b';
              ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            } else if (val === wireworldColors.electronHead) {
              ctx.fillStyle = '#2196f3';
              ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            } else if (val === wireworldColors.electronTail) {
              ctx.fillStyle = '#ff5722';
              ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            }
          } else if (grid[i][j] === 1 || grid[i][j] > 0) {
            if (gameMode === 'go' && colors[i][j]) {
              ctx.fillStyle = colors[i][j];
              if (colors[i][j] === '#fff') {
                ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#e0e0e0';
              } else {
                ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
              }
            } else if (gameMode === 'tetris' && colors[i][j]) {
              ctx.fillStyle = colors[i][j];
              ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            } else {
              ctx.fillStyle = '#2b59ff';
              ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            }
          }
        }
      }

      // Draw ant
      if (gameMode === 'ant') {
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(antCol * cellSize + cellSize / 2, antRow * cellSize + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function countNeighbors(row, col) {
      let count = 0;
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          if (i === 0 && j === 0) continue;
          const newRow = (row + i + rows) % rows;
          const newCol = (col + j + cols) % cols;
          count += grid[newRow][newCol];
        }
      }
      return count;
    }

    function nextGeneration() {
      if (gameMode === 'conway') {
        nextConway();
      } else if (gameMode === 'tetris') {
        nextTetris();
      } else if (gameMode === 'ant') {
        nextAnt();
      } else if (gameMode === 'sandpile') {
        nextSandpile();
      } else if (gameMode === 'wireworld') {
        nextWireworld();
      }
      generation++;
      generationDisplay.textContent = generation;
      drawGrid();
    }

    function nextConway() {
      const newGrid = createGrid();

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const neighbors = countNeighbors(i, j);
          const cell = grid[i][j];

          if (cell === 1 && (neighbors === 2 || neighbors === 3)) {
            newGrid[i][j] = 1;
          } else if (cell === 0 && neighbors === 3) {
            newGrid[i][j] = 1;
          }
        }
      }

      grid = newGrid;
    }

    function nextTetris() {
      // Move blocks down
      const newGrid = createGrid();
      const newColors = createGrid();

      for (let i = rows - 1; i >= 0; i--) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1) {
            if (i === rows - 1 || newGrid[i + 1][j] === 1) {
              newGrid[i][j] = 1;
              newColors[i][j] = colors[i][j];
            } else {
              newGrid[i + 1][j] = 1;
              newColors[i + 1][j] = colors[i][j];
            }
          }
        }
      }

      // Check for complete rows
      for (let i = 0; i < rows; i++) {
        let complete = true;
        for (let j = 0; j < cols; j++) {
          if (newGrid[i][j] === 0) {
            complete = false;
            break;
          }
        }
        if (complete) {
          for (let j = 0; j < cols; j++) {
            newGrid[i][j] = 0;
            newColors[i][j] = 0;
          }
        }
      }

      grid = newGrid;
      colors = newColors;
    }

    function nextAnt() {
      // Langton's ant: turn right on white, left on black
      if (grid[antRow][antCol] === 0) {
        // White cell: turn right, flip to black
        antDir = (antDir + 1) % 4;
        grid[antRow][antCol] = 1;
      } else {
        // Black cell: turn left, flip to white
        antDir = (antDir + 3) % 4;
        grid[antRow][antCol] = 0;
      }

      // Move forward
      if (antDir === 0) antRow = (antRow - 1 + rows) % rows;
      else if (antDir === 1) antCol = (antCol + 1) % cols;
      else if (antDir === 2) antRow = (antRow + 1) % rows;
      else if (antDir === 3) antCol = (antCol - 1 + cols) % cols;
    }

    function nextSandpile() {
      const newValues = sandpileValues.map(row => [...row]);
      let changed = false;

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (sandpileValues[i][j] >= 4) {
            changed = true;
            newValues[i][j] -= 4;
            if (i > 0) newValues[i - 1][j]++;
            if (i < rows - 1) newValues[i + 1][j]++;
            if (j > 0) newValues[i][j - 1]++;
            if (j < cols - 1) newValues[i][j + 1]++;
          }
        }
      }

      sandpileValues = newValues;
      if (!changed && generation > 0) {
        stop();
      }
    }

    function nextWireworld() {
      const newGrid = createGrid();

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const cell = grid[i][j];

          if (cell === wireworldColors.electronHead) {
            newGrid[i][j] = wireworldColors.electronTail;
          } else if (cell === wireworldColors.electronTail) {
            newGrid[i][j] = wireworldColors.conductor;
          } else if (cell === wireworldColors.conductor) {
            let headCount = 0;
            for (let di = -1; di <= 1; di++) {
              for (let dj = -1; dj <= 1; dj++) {
                if (di === 0 && dj === 0) continue;
                const ni = i + di;
                const nj = j + dj;
                if (ni >= 0 && ni < rows && nj >= 0 && nj < cols) {
                  if (grid[ni][nj] === wireworldColors.electronHead) {
                    headCount++;
                  }
                }
              }
            }
            if (headCount === 1 || headCount === 2) {
              newGrid[i][j] = wireworldColors.electronHead;
            } else {
              newGrid[i][j] = wireworldColors.conductor;
            }
          }
        }
      }

      grid = newGrid;
    }

    function start() {
      if (!running) {
        running = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        gameButtons.forEach(btn => btn.disabled = true);
        intervalId = setInterval(nextGeneration, gameMode === 'ant' ? 50 : 100);
      }
    }

    function stop() {
      running = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      gameButtons.forEach(btn => btn.disabled = false);
      clearInterval(intervalId);
    }

    function clear() {
      stop();
      grid = createGrid();
      colors = createGrid();
      sandpileValues = createGrid();
      gameMode = 'conway';
      generation = 0;
      generationDisplay.textContent = generation;
      setActiveGameButton(conwayBtn);
      drawGrid();
    }

    function randomize() {
      stop();
      grid = createGrid();
      colors = createGrid();
      sandpileValues = createGrid();
      gameMode = 'conway';
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          grid[i][j] = Math.random() > 0.7 ? 1 : 0;
        }
      }
      generation = 0;
      generationDisplay.textContent = generation;
      setActiveGameButton(conwayBtn);
      drawGrid();
    }

    function setActiveGameButton(activeBtn) {
      gameButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.disabled = (btn !== activeBtn);
      });
      activeBtn.classList.add('active');
      activeBtn.disabled = false;
    }

    function applyConway() {
      if (running) return;
      gameMode = 'conway';
      colors = createGrid();
      sandpileValues = createGrid();
      setActiveGameButton(conwayBtn);
      drawGrid();
    }

    function applyGo() {
      if (running) return;
      gameMode = 'go';
      colors = createGrid();

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1) {
            colors[i][j] = goColors[Math.floor(Math.random() * 2)];
          }
        }
      }

      removeGroupsWithoutLiberties();
      setActiveGameButton(goBtn);
      drawGrid();
    }

    function applyTetris() {
      if (running) return;
      gameMode = 'tetris';
      colors = createGrid();
      const visited = createGrid();
      let colorIndex = 0;

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1 && visited[i][j] === 0) {
            const color = tetrisColors[colorIndex % tetrisColors.length];
            floodFillColorTetris(i, j, color, visited);
            colorIndex++;
          }
        }
      }

      setActiveGameButton(tetrisBtn);
      drawGrid();
    }

    function floodFillColorTetris(row, col, color, visited) {
      const stack = [[row, col]];

      while (stack.length > 0) {
        const [r, c] = stack.pop();

        if (r < 0 || r >= rows || c < 0 || c >= cols) continue;
        if (visited[r][c] === 1 || grid[r][c] === 0) continue;

        visited[r][c] = 1;
        colors[r][c] = color;

        stack.push([r - 1, c]);
        stack.push([r + 1, c]);
        stack.push([r, c - 1]);
        stack.push([r, c + 1]);
      }
    }

    function applyAnt() {
      if (running) return;
      gameMode = 'ant';

      // Find a random living cell or center
      let foundLiving = false;
      for (let i = 0; i < rows && !foundLiving; i++) {
        for (let j = 0; j < cols && !foundLiving; j++) {
          if (grid[i][j] === 1 && Math.random() > 0.8) {
            antRow = i;
            antCol = j;
            foundLiving = true;
          }
        }
      }
      if (!foundLiving) {
        antRow = Math.floor(rows / 2);
        antCol = Math.floor(cols / 2);
      }
      antDir = 0;

      setActiveGameButton(antBtn);
      drawGrid();
    }

    function applySandpile() {
      if (running) return;
      gameMode = 'sandpile';
      sandpileValues = createGrid();

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1) {
            sandpileValues[i][j] = Math.floor(Math.random() * 8) + 1;
          }
        }
      }

      setActiveGameButton(sandpileBtn);
      drawGrid();
    }

    function applyWireworld() {
      if (running) return;
      gameMode = 'wireworld';

      // Find connected groups and assign one head and one tail per group
      const visited = createGrid();

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1 && visited[i][j] === 0) {
            // Find all cells in this group
            const groupCells = [];
            findGroupCells(i, j, visited, groupCells);

            // Convert all to conductors first
            for (const [r, c] of groupCells) {
              grid[r][c] = wireworldColors.conductor;
            }

            // Randomly pick one for head and one for tail
            if (groupCells.length > 0) {
              const headIdx = Math.floor(Math.random() * groupCells.length);
              const [headR, headC] = groupCells[headIdx];
              grid[headR][headC] = wireworldColors.electronHead;

              if (groupCells.length > 1) {
                let tailIdx = Math.floor(Math.random() * groupCells.length);
                while (tailIdx === headIdx) {
                  tailIdx = Math.floor(Math.random() * groupCells.length);
                }
                const [tailR, tailC] = groupCells[tailIdx];
                grid[tailR][tailC] = wireworldColors.electronTail;
              }
            }
          }
        }
      }

      setActiveGameButton(wireworldBtn);
      drawGrid();
    }

    function findGroupCells(row, col, visited, groupCells) {
      if (row < 0 || row >= rows || col < 0 || col >= cols) return;
      if (visited[row][col] === 1 || grid[row][col] === 0) return;

      visited[row][col] = 1;
      groupCells.push([row, col]);

      findGroupCells(row - 1, col, visited, groupCells);
      findGroupCells(row + 1, col, visited, groupCells);
      findGroupCells(row, col - 1, visited, groupCells);
      findGroupCells(row, col + 1, visited, groupCells);
    }

    function getLiberties(row, col, groupColor, visited, groupCells) {
      if (row < 0 || row >= rows || col < 0 || col >= cols) return 0;
      if (visited[row][col] === 1) return 0;

      visited[row][col] = 1;

      if (grid[row][col] === 0) {
        return 1; // Empty space is a liberty
      }

      // Only continue if same color
      if (colors[row][col] !== groupColor) {
        return 0;
      }

      groupCells.push([row, col]);

      let liberties = 0;
      liberties += getLiberties(row - 1, col, groupColor, visited, groupCells);
      liberties += getLiberties(row + 1, col, groupColor, visited, groupCells);
      liberties += getLiberties(row, col - 1, groupColor, visited, groupCells);
      liberties += getLiberties(row, col + 1, groupColor, visited, groupCells);

      return liberties;
    }

    function removeGroupsWithoutLiberties() {
      const visited = createGrid();

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1 && visited[i][j] === 0) {
            const groupCells = [];
            const groupColor = colors[i][j];
            const liberties = getLiberties(i, j, groupColor, visited, groupCells);

            if (liberties === 0) {
              // Remove this group
              for (const [r, c] of groupCells) {
                grid[r][c] = 0;
                colors[r][c] = 0;
              }
            }
          }
        }
      }
    }

    canvas.addEventListener('click', (e) => {
      if (running) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const col = Math.floor(x / cellSize);
      const row = Math.floor(y / cellSize);

      if (row >= 0 && row < rows && col >= 0 && col < cols) {
        grid[row][col] = grid[row][col] === 1 ? 0 : 1;
        drawGrid();
      }
    });

    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
    clearBtn.addEventListener('click', clear);
    randomBtn.addEventListener('click', randomize);
    conwayBtn.addEventListener('click', applyConway);
    goBtn.addEventListener('click', applyGo);
    tetrisBtn.addEventListener('click', applyTetris);
    antBtn.addEventListener('click', applyAnt);
    sandpileBtn.addEventListener('click', applySandpile);
    wireworldBtn.addEventListener('click', applyWireworld);

    // Initial draw
    drawGrid();
  </script>
</body>
</html>
