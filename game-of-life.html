<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Grid! - Charlie Sands</title>
  <style>
    html, body { background: #fff; color: #111; margin: 0; padding: 0; }
    body { font: 16px/1.6 ui-serif, Georgia, Cambria, "Times New Roman", Times, serif; }
    .wrap { max-width: 800px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 24px; margin: 0 0 16px; }
    .controls { margin: 16px 0; display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    button {
      padding: 8px 16px;
      background: #2b59ff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover { background: #1e42cc; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    button.active { background: #ff5722; }
    #canvas {
      border: 1px solid #ddd;
      cursor: crosshair;
      display: block;
      margin: 16px 0;
    }
    .info { font-size: 14px; color: #555; margin: 8px 0; }
    .back { margin-top: 24px; font-size: 14px; }
    a { color: #2b59ff; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <main class="wrap">
    <h1>Grid!</h1>
    <p class="info">Click cells to toggle them. Press Start to begin simulation.</p>

    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <button id="clearBtn">Clear</button>
      <button id="randomBtn">Random</button>
      <span class="info">Speed: <input type="range" id="speedSlider" min="1" max="20" value="10" style="width: 100px; vertical-align: middle;"></span>
      <span class="info">Generation: <span id="generation">0</span></span>
    </div>
    <div class="controls">
      <button id="conwayBtn" class="active">Conway</button>
      <button id="goBtn">Go!</button>
      <button id="tetrisBtn">Tetris</button>
      <button id="antBtn">Langton's Ant</button>
      <button id="sandpileBtn">Sandpile</button>
      <button id="wireworldBtn">Wireworld</button>
    </div>

    <canvas id="canvas" width="600" height="400"></canvas>

    <p class="back"><a href="index.html">‚Üê Back to home</a></p>
  </main>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const clearBtn = document.getElementById('clearBtn');
    const randomBtn = document.getElementById('randomBtn');
    const conwayBtn = document.getElementById('conwayBtn');
    const goBtn = document.getElementById('goBtn');
    const tetrisBtn = document.getElementById('tetrisBtn');
    const antBtn = document.getElementById('antBtn');
    const sandpileBtn = document.getElementById('sandpileBtn');
    const wireworldBtn = document.getElementById('wireworldBtn');
    const generationDisplay = document.getElementById('generation');
    const speedSlider = document.getElementById('speedSlider');

    const gameButtons = [conwayBtn, goBtn, tetrisBtn, antBtn, sandpileBtn, wireworldBtn];

    const cellSize = 10;
    const cols = canvas.width / cellSize;
    const rows = canvas.height / cellSize;

    let grid = createGrid();
    let colors = createGrid();
    let sandpileValues = createGrid(); // For sandpile mode
    let running = false;
    let generation = 0;
    let intervalId = null;
    let gameMode = 'conway'; // 'conway', 'go', 'tetris', 'ant', 'sandpile', 'wireworld'

    // Ant state - array of 5 ants
    let ants = [];
    for (let i = 0; i < 5; i++) {
      ants.push({ row: 0, col: 0, dir: 0 }); // dir: 0=up, 1=right, 2=down, 3=left
    }

    // Two colors for Go stones (black and white)
    const goColors = ['#111', '#fff'];

    // Tetris colors
    const tetrisColors = [
      '#ff5722', '#2196f3', '#4caf50', '#ff9800',
      '#9c27b0', '#00bcd4', '#ffeb3b', '#e91e63'
    ];

    // Wireworld colors
    const wireworldColors = {
      empty: 0,
      conductor: 1,
      electronHead: 2,
      electronTail: 3
    };

    function createGrid() {
      return Array(rows).fill(null).map(() => Array(cols).fill(0));
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          ctx.strokeStyle = '#e0e0e0';
          ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);

          if (gameMode === 'sandpile') {
            const val = sandpileValues[i][j];
            if (val > 0) {
              const intensity = Math.min(val * 50, 255);
              ctx.fillStyle = `rgb(${intensity}, ${Math.max(0, 200 - val * 30)}, ${Math.max(0, 100 - val * 20)})`;
              ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
              if (val < 10) {
                ctx.fillStyle = '#000';
                ctx.font = '8px monospace';
                ctx.fillText(val, j * cellSize + 2, i * cellSize + 8);
              }
            }
          } else if (gameMode === 'wireworld') {
            const val = grid[i][j];
            if (val === wireworldColors.conductor) {
              ctx.fillStyle = '#ffeb3b';
              ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            } else if (val === wireworldColors.electronHead) {
              ctx.fillStyle = '#2196f3';
              ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            } else if (val === wireworldColors.electronTail) {
              ctx.fillStyle = '#ff5722';
              ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            }
          } else if (grid[i][j] === 1 || grid[i][j] > 0) {
            if (gameMode === 'go' && colors[i][j]) {
              ctx.fillStyle = colors[i][j];
              if (colors[i][j] === '#fff') {
                ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#e0e0e0';
              } else {
                ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
              }
            } else if (gameMode === 'tetris' && colors[i][j]) {
              ctx.fillStyle = colors[i][j];
              ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            } else {
              ctx.fillStyle = '#2b59ff';
              ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
            }
          }
        }
      }

      // Draw ants
      if (gameMode === 'ant') {
        const antColors = ['#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#ffff00'];
        ants.forEach((ant, idx) => {
          ctx.fillStyle = antColors[idx % antColors.length];
          ctx.beginPath();
          ctx.arc(ant.col * cellSize + cellSize / 2, ant.row * cellSize + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }
    }

    function countNeighbors(row, col) {
      let count = 0;
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          if (i === 0 && j === 0) continue;
          const newRow = (row + i + rows) % rows;
          const newCol = (col + j + cols) % cols;
          count += grid[newRow][newCol];
        }
      }
      return count;
    }

    function nextGeneration() {
      if (gameMode === 'conway') {
        nextConway();
      } else if (gameMode === 'tetris') {
        nextTetris();
      } else if (gameMode === 'ant') {
        nextAnt();
      } else if (gameMode === 'sandpile') {
        nextSandpile();
      } else if (gameMode === 'wireworld') {
        nextWireworld();
      }
      generation++;
      generationDisplay.textContent = generation;
      drawGrid();
    }

    function nextConway() {
      const newGrid = createGrid();

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const neighbors = countNeighbors(i, j);
          const cell = grid[i][j];

          if (cell === 1 && (neighbors === 2 || neighbors === 3)) {
            newGrid[i][j] = 1;
          } else if (cell === 0 && neighbors === 3) {
            newGrid[i][j] = 1;
          }
        }
      }

      grid = newGrid;
    }

    function nextTetris() {
      // Identify all connected shapes (not just by color, but by connectivity)
      const visited = createGrid();
      const shapes = [];

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1 && visited[i][j] === 0) {
            const shapeCells = [];
            const color = colors[i][j];
            floodFillTetrisShape(i, j, color, visited, shapeCells);
            shapes.push({ cells: shapeCells, color: color });
          }
        }
      }

      // Build new grid by checking each shape independently
      const newGrid = createGrid();
      const newColors = createGrid();
      let anyShapeMoved = false;

      // Sort shapes by their lowest row (process from bottom to top)
      shapes.sort((a, b) => {
        const maxRowA = Math.max(...a.cells.map(([r, c]) => r));
        const maxRowB = Math.max(...b.cells.map(([r, c]) => r));
        return maxRowB - maxRowA;
      });

      for (const shape of shapes) {
        const shapeCells = shape.cells;
        const color = shape.color;
        let canMoveDown = true;

        // Check if entire shape can move down
        for (const [r, c] of shapeCells) {
          if (r === rows - 1) {
            // Hit bottom
            canMoveDown = false;
            break;
          }

          const cellBelow = [r + 1, c];
          const isCellBelowInSameShape = shapeCells.some(([sr, sc]) => sr === cellBelow[0] && sc === cellBelow[1]);

          if (!isCellBelowInSameShape) {
            // Check if the new grid already has something there (from a shape we've already placed)
            if (newGrid[r + 1][c] === 1) {
              canMoveDown = false;
              break;
            }
          }
        }

        // Place shape in new grid
        if (canMoveDown) {
          anyShapeMoved = true;
          // Move shape down
          for (const [r, c] of shapeCells) {
            newGrid[r + 1][c] = 1;
            newColors[r + 1][c] = color;
          }
        } else {
          // Keep shape in place
          for (const [r, c] of shapeCells) {
            newGrid[r][c] = 1;
            newColors[r][c] = color;
          }
        }
      }

      // Check for complete rows and remove them
      for (let i = 0; i < rows; i++) {
        let complete = true;
        for (let j = 0; j < cols; j++) {
          if (newGrid[i][j] === 0) {
            complete = false;
            break;
          }
        }
        if (complete) {
          // Clear the row
          for (let j = 0; j < cols; j++) {
            newGrid[i][j] = 0;
            newColors[i][j] = 0;
          }
        }
      }

      grid = newGrid;
      colors = newColors;

      // Stop if no shapes moved and no rows were cleared
      if (!anyShapeMoved && generation > 0) {
        stop();
      }
    }

    function floodFillTetrisShape(row, col, color, visited, shapeCells) {
      if (row < 0 || row >= rows || col < 0 || col >= cols) return;
      if (visited[row][col] === 1 || grid[row][col] === 0) return;
      if (colors[row][col] !== color) return;

      visited[row][col] = 1;
      shapeCells.push([row, col]);

      floodFillTetrisShape(row - 1, col, color, visited, shapeCells);
      floodFillTetrisShape(row + 1, col, color, visited, shapeCells);
      floodFillTetrisShape(row, col - 1, color, visited, shapeCells);
      floodFillTetrisShape(row, col + 1, color, visited, shapeCells);
    }

    function nextAnt() {
      // Move each ant according to Langton's ant rules
      ants.forEach(ant => {
        // Langton's ant: turn right on white, left on black
        if (grid[ant.row][ant.col] === 0) {
          // White cell: turn right, flip to black
          ant.dir = (ant.dir + 1) % 4;
          grid[ant.row][ant.col] = 1;
        } else {
          // Black cell: turn left, flip to white
          ant.dir = (ant.dir + 3) % 4;
          grid[ant.row][ant.col] = 0;
        }

        // Move forward
        if (ant.dir === 0) ant.row = (ant.row - 1 + rows) % rows;
        else if (ant.dir === 1) ant.col = (ant.col + 1) % cols;
        else if (ant.dir === 2) ant.row = (ant.row + 1) % rows;
        else if (ant.dir === 3) ant.col = (ant.col - 1 + cols) % cols;
      });
    }

    function nextSandpile() {
      const newValues = sandpileValues.map(row => [...row]);
      let changed = false;

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (sandpileValues[i][j] >= 4) {
            changed = true;
            newValues[i][j] -= 4;
            if (i > 0) newValues[i - 1][j]++;
            if (i < rows - 1) newValues[i + 1][j]++;
            if (j > 0) newValues[i][j - 1]++;
            if (j < cols - 1) newValues[i][j + 1]++;
          }
        }
      }

      sandpileValues = newValues;
      if (!changed && generation > 0) {
        stop();
      }
    }

    function nextWireworld() {
      const newGrid = createGrid();

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const cell = grid[i][j];

          if (cell === wireworldColors.electronHead) {
            newGrid[i][j] = wireworldColors.electronTail;
          } else if (cell === wireworldColors.electronTail) {
            newGrid[i][j] = wireworldColors.conductor;
          } else if (cell === wireworldColors.conductor) {
            let headCount = 0;
            for (let di = -1; di <= 1; di++) {
              for (let dj = -1; dj <= 1; dj++) {
                if (di === 0 && dj === 0) continue;
                const ni = i + di;
                const nj = j + dj;
                if (ni >= 0 && ni < rows && nj >= 0 && nj < cols) {
                  if (grid[ni][nj] === wireworldColors.electronHead) {
                    headCount++;
                  }
                }
              }
            }
            if (headCount === 1 || headCount === 2) {
              newGrid[i][j] = wireworldColors.electronHead;
            } else {
              newGrid[i][j] = wireworldColors.conductor;
            }
          }
        }
      }

      grid = newGrid;
    }

    function getSpeed() {
      // Convert slider value (1-20) to interval time in ms
      // Higher slider value = faster speed = lower interval
      // 1 = 500ms (slow), 10 = 100ms (medium), 20 = 25ms (fast)
      const sliderValue = parseInt(speedSlider.value);
      return Math.max(25, 525 - sliderValue * 25);
    }

    function start() {
      if (!running) {
        running = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        gameButtons.forEach(btn => btn.disabled = true);
        intervalId = setInterval(nextGeneration, getSpeed());
      }
    }

    function stop() {
      running = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      gameButtons.forEach(btn => btn.disabled = false);
      clearInterval(intervalId);
    }

    function updateSpeed() {
      if (running) {
        clearInterval(intervalId);
        intervalId = setInterval(nextGeneration, getSpeed());
      }
    }

    function clear() {
      stop();
      grid = createGrid();
      colors = createGrid();
      sandpileValues = createGrid();
      gameMode = 'conway';
      generation = 0;
      generationDisplay.textContent = generation;
      setActiveGameButton(conwayBtn);
      drawGrid();
    }

    function randomize() {
      stop();
      grid = createGrid();
      colors = createGrid();
      sandpileValues = createGrid();
      gameMode = 'conway';
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          grid[i][j] = Math.random() > 0.7 ? 1 : 0;
        }
      }
      generation = 0;
      generationDisplay.textContent = generation;
      setActiveGameButton(conwayBtn);
      drawGrid();
    }

    function setActiveGameButton(activeBtn) {
      gameButtons.forEach(btn => {
        btn.classList.remove('active');
        // Only disable other buttons if running
        if (running) {
          btn.disabled = (btn !== activeBtn);
        } else {
          btn.disabled = false;
        }
      });
      activeBtn.classList.add('active');
    }

    function applyConway() {
      if (running) return;

      // If switching FROM sandpile mode, convert any cells with values to living cells
      if (gameMode === 'sandpile') {
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (sandpileValues[i][j] > 0) {
              grid[i][j] = 1;
            }
          }
        }
      }

      // If switching FROM wireworld, convert all non-empty cells to living cells
      if (gameMode === 'wireworld') {
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (grid[i][j] > 0) {
              grid[i][j] = 1;
            }
          }
        }
      }

      gameMode = 'conway';
      colors = createGrid();
      sandpileValues = createGrid();
      setActiveGameButton(conwayBtn);
      startBtn.disabled = false; // Re-enable start for iterative modes
      drawGrid();
    }

    function applyGo() {
      if (running) return;

      // If switching FROM sandpile mode, convert any cells with values to living cells
      if (gameMode === 'sandpile') {
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (sandpileValues[i][j] > 0) {
              grid[i][j] = 1;
            }
          }
        }
      }

      // If switching FROM wireworld, convert all non-empty cells to living cells
      if (gameMode === 'wireworld') {
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (grid[i][j] > 0) {
              grid[i][j] = 1;
            }
          }
        }
      }

      // Go mode does not iterate, so disable start button
      gameMode = 'go';
      colors = createGrid();

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1) {
            colors[i][j] = goColors[Math.floor(Math.random() * 2)];
          }
        }
      }

      removeGroupsWithoutLiberties();
      setActiveGameButton(goBtn);
      startBtn.disabled = true; // Go doesn't iterate
      drawGrid();
    }

    function applyTetris() {
      if (running) return;

      // If switching FROM sandpile mode, convert any cells with values to living cells
      if (gameMode === 'sandpile') {
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (sandpileValues[i][j] > 0) {
              grid[i][j] = 1;
            }
          }
        }
      }

      // If switching FROM wireworld, convert all non-empty cells to living cells
      if (gameMode === 'wireworld') {
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (grid[i][j] > 0) {
              grid[i][j] = 1;
            }
          }
        }
      }

      gameMode = 'tetris';
      colors = createGrid();
      const visited = createGrid();
      let colorIndex = 0;

      // Assign colors to all existing living cells based on connected components
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1 && visited[i][j] === 0) {
            const color = tetrisColors[colorIndex % tetrisColors.length];
            floodFillColorTetris(i, j, color, visited);
            colorIndex++;
          }
        }
      }

      setActiveGameButton(tetrisBtn);
      startBtn.disabled = false; // Re-enable start for iterative modes
      drawGrid();
    }

    function floodFillColorTetris(row, col, color, visited) {
      const stack = [[row, col]];

      while (stack.length > 0) {
        const [r, c] = stack.pop();

        if (r < 0 || r >= rows || c < 0 || c >= cols) continue;
        if (visited[r][c] === 1 || grid[r][c] === 0) continue;

        visited[r][c] = 1;
        colors[r][c] = color;

        stack.push([r - 1, c]);
        stack.push([r + 1, c]);
        stack.push([r, c - 1]);
        stack.push([r, c + 1]);
      }
    }

    function applyAnt() {
      if (running) return;

      // If switching FROM sandpile mode, convert any cells with values to living cells
      if (gameMode === 'sandpile') {
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (sandpileValues[i][j] > 0) {
              grid[i][j] = 1;
            }
          }
        }
      }

      // If switching FROM wireworld, convert all non-empty cells to living cells
      if (gameMode === 'wireworld') {
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (grid[i][j] > 0) {
              grid[i][j] = 1;
            }
          }
        }
      }

      gameMode = 'ant';

      // Initialize 5 ants at different positions
      const livingCells = [];
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1) {
            livingCells.push([i, j]);
          }
        }
      }

      // Place ants either on living cells or spread them out
      if (livingCells.length >= 5) {
        // Randomly select 5 living cells
        const shuffled = livingCells.sort(() => Math.random() - 0.5);
        for (let i = 0; i < 5; i++) {
          ants[i].row = shuffled[i][0];
          ants[i].col = shuffled[i][1];
          ants[i].dir = Math.floor(Math.random() * 4);
        }
      } else {
        // Spread ants across the grid
        for (let i = 0; i < 5; i++) {
          ants[i].row = Math.floor(rows / 6 * (i + 1));
          ants[i].col = Math.floor(cols / 2);
          ants[i].dir = i % 4;
        }
      }

      setActiveGameButton(antBtn);
      startBtn.disabled = false; // Re-enable start for iterative modes
      drawGrid();
    }

    function applySandpile() {
      if (running) return;

      // If switching FROM sandpile mode, convert any cells with values to living cells
      if (gameMode === 'sandpile') {
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (sandpileValues[i][j] > 0) {
              grid[i][j] = 1;
            }
          }
        }
      }

      // If switching FROM wireworld, convert all non-empty cells to living cells
      if (gameMode === 'wireworld') {
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (grid[i][j] > 0) {
              grid[i][j] = 1;
            }
          }
        }
      }

      gameMode = 'sandpile';
      sandpileValues = createGrid();

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1 || grid[i][j] > 0) {
            sandpileValues[i][j] = Math.floor(Math.random() * 8) + 1;
          }
        }
      }

      setActiveGameButton(sandpileBtn);
      startBtn.disabled = false; // Re-enable start for iterative modes
      drawGrid();
    }

    function applyWireworld() {
      if (running) return;

      // If switching FROM sandpile mode, convert any cells with values to living cells
      if (gameMode === 'sandpile') {
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (sandpileValues[i][j] > 0) {
              grid[i][j] = 1;
            }
          }
        }
      }

      gameMode = 'wireworld';

      // Find connected groups and assign one head and one tail per group
      const visited = createGrid();

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1 && visited[i][j] === 0) {
            // Find all cells in this group
            const groupCells = [];
            findGroupCells(i, j, visited, groupCells);

            // Convert all to conductors first
            for (const [r, c] of groupCells) {
              grid[r][c] = wireworldColors.conductor;
            }

            // Randomly pick one for head and one for tail
            if (groupCells.length > 0) {
              const headIdx = Math.floor(Math.random() * groupCells.length);
              const [headR, headC] = groupCells[headIdx];
              grid[headR][headC] = wireworldColors.electronHead;

              if (groupCells.length > 1) {
                let tailIdx = Math.floor(Math.random() * groupCells.length);
                while (tailIdx === headIdx) {
                  tailIdx = Math.floor(Math.random() * groupCells.length);
                }
                const [tailR, tailC] = groupCells[tailIdx];
                grid[tailR][tailC] = wireworldColors.electronTail;
              }
            }
          }
        }
      }

      setActiveGameButton(wireworldBtn);
      startBtn.disabled = false; // Re-enable start for iterative modes
      drawGrid();
    }

    function findGroupCells(row, col, visited, groupCells) {
      if (row < 0 || row >= rows || col < 0 || col >= cols) return;
      if (visited[row][col] === 1 || grid[row][col] === 0) return;

      visited[row][col] = 1;
      groupCells.push([row, col]);

      findGroupCells(row - 1, col, visited, groupCells);
      findGroupCells(row + 1, col, visited, groupCells);
      findGroupCells(row, col - 1, visited, groupCells);
      findGroupCells(row, col + 1, visited, groupCells);
    }

    function getLiberties(row, col, groupColor, visited, groupCells) {
      if (row < 0 || row >= rows || col < 0 || col >= cols) return 0;
      if (visited[row][col] === 1) return 0;

      visited[row][col] = 1;

      if (grid[row][col] === 0) {
        return 1; // Empty space is a liberty
      }

      // Only continue if same color
      if (colors[row][col] !== groupColor) {
        return 0;
      }

      groupCells.push([row, col]);

      let liberties = 0;
      liberties += getLiberties(row - 1, col, groupColor, visited, groupCells);
      liberties += getLiberties(row + 1, col, groupColor, visited, groupCells);
      liberties += getLiberties(row, col - 1, groupColor, visited, groupCells);
      liberties += getLiberties(row, col + 1, groupColor, visited, groupCells);

      return liberties;
    }

    function removeGroupsWithoutLiberties() {
      const visited = createGrid();

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === 1 && visited[i][j] === 0) {
            const groupCells = [];
            const groupColor = colors[i][j];
            const liberties = getLiberties(i, j, groupColor, visited, groupCells);

            if (liberties === 0) {
              // Remove this group
              for (const [r, c] of groupCells) {
                grid[r][c] = 0;
                colors[r][c] = 0;
              }
            }
          }
        }
      }
    }

    canvas.addEventListener('click', (e) => {
      if (running) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const col = Math.floor(x / cellSize);
      const row = Math.floor(y / cellSize);

      if (row >= 0 && row < rows && col >= 0 && col < cols) {
        if (gameMode === 'conway') {
          grid[row][col] = grid[row][col] === 1 ? 0 : 1;
        } else if (gameMode === 'go') {
          if (grid[row][col] === 1) {
            grid[row][col] = 0;
            colors[row][col] = 0;
          } else {
            grid[row][col] = 1;
            colors[row][col] = goColors[Math.floor(Math.random() * 2)];
          }
        } else if (gameMode === 'tetris') {
          if (grid[row][col] === 1) {
            grid[row][col] = 0;
            colors[row][col] = 0;
          } else {
            grid[row][col] = 1;
            // Assign a random color
            colors[row][col] = tetrisColors[Math.floor(Math.random() * tetrisColors.length)];
          }
        } else if (gameMode === 'ant') {
          grid[row][col] = grid[row][col] === 1 ? 0 : 1;
        } else if (gameMode === 'sandpile') {
          if (sandpileValues[row][col] > 0) {
            sandpileValues[row][col] = 0;
            grid[row][col] = 0;
          } else {
            sandpileValues[row][col] = Math.floor(Math.random() * 8) + 1;
            grid[row][col] = 1;
          }
        } else if (gameMode === 'wireworld') {
          if (grid[row][col] === 0) {
            grid[row][col] = wireworldColors.conductor;
          } else {
            grid[row][col] = 0;
          }
        }
        drawGrid();
      }
    });

    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
    clearBtn.addEventListener('click', clear);
    randomBtn.addEventListener('click', randomize);
    conwayBtn.addEventListener('click', applyConway);
    goBtn.addEventListener('click', applyGo);
    tetrisBtn.addEventListener('click', applyTetris);
    antBtn.addEventListener('click', applyAnt);
    sandpileBtn.addEventListener('click', applySandpile);
    wireworldBtn.addEventListener('click', applyWireworld);
    speedSlider.addEventListener('input', updateSpeed);

    // Initial draw
    drawGrid();
  </script>
</body>
</html>
